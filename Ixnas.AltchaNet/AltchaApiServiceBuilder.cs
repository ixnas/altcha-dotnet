using System;
using Ixnas.AltchaNet.Debug;
using Ixnas.AltchaNet.Exceptions;
using Ixnas.AltchaNet.Internal;
using Ixnas.AltchaNet.Internal.Common.Converters;
using Ixnas.AltchaNet.Internal.Common.Cryptography;
using Ixnas.AltchaNet.Internal.Common.Salt;
using Ixnas.AltchaNet.Internal.Common.Serialization;
using Ixnas.AltchaNet.Internal.Common.Stores;
using Ixnas.AltchaNet.Internal.Common.Utilities;
using Ixnas.AltchaNet.Internal.ProofOfWork;
using Ixnas.AltchaNet.Internal.ProofOfWork.Common;
using Ixnas.AltchaNet.Internal.ProofOfWork.Validation;
using Ixnas.AltchaNet.Internal.SpamFilter;

namespace Ixnas.AltchaNet
{
    /// <summary>
    ///     Builds the service that can validate ALTCHA challenges generated by the ALTCHA project's own API.
    /// </summary>
    public sealed class AltchaApiServiceBuilder
    {
        private readonly Clock _clock = new DefaultClock();
        private readonly byte[] _key;
        private readonly double _maxSpamFilterScore = Defaults.MaxSpamFilterScore;
        private readonly Func<IAltchaCancellableChallengeStore> _storeFactory;
        private readonly bool _useInMemoryStore;

        internal AltchaApiServiceBuilder()
        {
        }

        private AltchaApiServiceBuilder(byte[] key,
                                        bool useInMemoryStore,
                                        Func<IAltchaCancellableChallengeStore> storeFactory,
                                        Clock clock,
                                        double maxSpamFilterScore)
        {
            _key = key;
            _useInMemoryStore = useInMemoryStore;
            _storeFactory = storeFactory;
            _clock = clock;
            _maxSpamFilterScore = maxSpamFilterScore;
        }

        /// <summary>
        ///     Returns a new configured service instance.
        /// </summary>
        public AltchaApiService Build()
        {
            if (!_useInMemoryStore && _storeFactory == null)
                throw new MissingStoreException();
            if (_key == null)
                throw new MissingApiSecretException();
            var inMemoryStore = new InMemoryStore(_clock);
            var inMemoryStoreWrapped = new ChallengeStoreAdapter(inMemoryStore);
            var storeFactory = _storeFactory ?? (() => inMemoryStoreWrapped);
            var serializer = new SystemTextJsonSerializer();
            var cryptoAlgorithm = new Sha256CryptoAlgorithm(_key);
            var saltParser = new SaltParser(_clock);
            var responseValidatorPayloadConverter =
                new ApiPayloadConverter();
            var responseValidatorSignatureParser =
                new SignatureParser(responseValidatorPayloadConverter,
                                    cryptoAlgorithm);
            var challengeStringGenerator =
                new ChallengeStringGenerator(cryptoAlgorithm);
            var challengeFactory = new ChallengeParser(cryptoAlgorithm, saltParser, challengeStringGenerator);
            var spamFilterValidatorPayloadConverter =
                new ApiSpamFilterPayloadConverter(cryptoAlgorithm);
            var spamFilterValidatorSignatureParser =
                new SignatureParser(spamFilterValidatorPayloadConverter,
                                    cryptoAlgorithm);
            var responseValidatorAltchaParser = new AltchaResponseParser(challengeFactory,
                                                                             responseValidatorSignatureParser);
            var responseValidator = new ResponseValidator(storeFactory,
                                                          responseValidatorAltchaParser,
                                                          serializer);
            var spamFilterValidator =
                new SpamFilterValidator(serializer,
                                        cryptoAlgorithm,
                                        _clock,
                                        storeFactory,
                                        spamFilterValidatorSignatureParser,
                                        _maxSpamFilterScore);
            return new AltchaApiService(responseValidator, spamFilterValidator);
        }

        /// <summary>
        ///     (Required) Configures the API secret used to validate challenges from ALTCHA's API.
        /// </summary>
        /// <param name="apiSecret">The key to use. Starts with "sec_" or "csec_".</param>
        /// <returns>A new instance of the builder with the updated configuration.</returns>
        public AltchaApiServiceBuilder UseApiSecret(string apiSecret)
        {
            if (string.IsNullOrWhiteSpace(apiSecret))
                throw new InvalidApiSecretException();

            if (!apiSecret.StartsWith("csec_") && !apiSecret.StartsWith("sec_"))
                throw new InvalidApiSecretException();

            var key = ByteConverter.GetByteArrayFromUtf8String(apiSecret);
            return new AltchaApiServiceBuilder(key,
                                               _useInMemoryStore,
                                               _storeFactory,
                                               _clock,
                                               _maxSpamFilterScore);
        }

        /// <summary>
        ///     Configures a simple in-memory store for previously verified ALTCHA responses. Should only be used for testing
        ///     purposes.
        /// </summary>
        /// <returns>A new instance of the builder with the updated configuration.</returns>
        public AltchaApiServiceBuilder UseInMemoryStore()
        {
            return new AltchaApiServiceBuilder(_key,
                                               true,
                                               null,
                                               _clock,
                                               _maxSpamFilterScore);
        }

        /// <summary>
        ///     (Required) Configures a store to use for previously verified ALTCHA responses. Used to prevent replay attacks.
        /// </summary>
        /// <param name="store">Store to use.</param>
        /// <returns>A new instance of the builder with the updated configuration.</returns>
        public AltchaApiServiceBuilder UseStore(IAltchaChallengeStore store)
        {
            Guard.NotNull(store);
            return new AltchaApiServiceBuilder(_key,
                                               _useInMemoryStore,
                                               () => new ChallengeStoreAdapter(store),
                                               _clock,
                                               _maxSpamFilterScore);
        }

        /// <summary>
        ///     (Required) Configures a store to use for previously verified ALTCHA responses. Used to prevent replay attacks.
        /// </summary>
        /// <param name="store">Store to use that supports CancellationTokens.</param>
        /// <returns>A new instance of the builder with the updated configuration.</returns>
        public AltchaApiServiceBuilder UseStore(IAltchaCancellableChallengeStore store)
        {
            Guard.NotNull(store);
            return new AltchaApiServiceBuilder(_key,
                                               _useInMemoryStore,
                                               () => store,
                                               _clock,
                                               _maxSpamFilterScore);
        }

        /// <summary>
        ///     (Required) Configures a store factory to use for previously verified ALTCHA responses. Used to prevent replay
        ///     attacks.
        /// </summary>
        /// <param name="storeFactory">Store factory function to use.</param>
        /// <returns>A new instance of the builder with the updated configuration.</returns>
        public AltchaApiServiceBuilder UseStore(Func<IAltchaChallengeStore> storeFactory)
        {
            Guard.NotNull(storeFactory);
            return new AltchaApiServiceBuilder(_key,
                                               _useInMemoryStore,
                                               () => new ChallengeStoreAdapter(storeFactory()),
                                               _clock,
                                               _maxSpamFilterScore);
        }

        /// <summary>
        ///     (Required) Configures a store factory to use for previously verified ALTCHA responses. Used to prevent replay
        ///     attacks.
        /// </summary>
        /// <param name="storeFactory">Store factory function to use of which the store supports CancellationTokens.</param>
        /// <returns>A new instance of the builder with the updated configuration.</returns>
        public AltchaApiServiceBuilder UseStore(Func<IAltchaCancellableChallengeStore> storeFactory)
        {
            Guard.NotNull(storeFactory);
            return new AltchaApiServiceBuilder(_key,
                                               _useInMemoryStore,
                                               storeFactory,
                                               _clock,
                                               _maxSpamFilterScore);
        }

        /// <summary>
        ///     (Optional) Overrides the default maximum score that a spam filtered form may have before it's rejected.
        /// </summary>
        /// <param name="maxScore">The maximum score (default 2)</param>
        /// <returns>A new instance of the builder with the updated configuration.</returns>
        public AltchaApiServiceBuilder SetMaxSpamFilterScore(double maxScore)
        {
            if (maxScore <= 0)
                throw new InvalidMaxSpamFilterScoreException();
            return new AltchaApiServiceBuilder(_key,
                                               _useInMemoryStore,
                                               _storeFactory,
                                               _clock,
                                               maxScore);
        }

#if DEBUG
        /// <summary>
        ///     DEBUG ONLY: Provide an alternative clock implementation. Used for testing time based logic.
        /// </summary>
        /// <param name="clock">An alternative clock implementation.</param>
        /// <returns>A new instance of the builder with the updated configuration.</returns>
        public AltchaApiServiceBuilder UseClock(Clock clock)
        {
            return new AltchaApiServiceBuilder(_key,
                                               _useInMemoryStore,
                                               _storeFactory,
                                               clock,
                                               _maxSpamFilterScore);
        }
#endif
    }
}
